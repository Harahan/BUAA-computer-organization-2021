# p5,p6加指令详谈

​       笔者好不容易过了``p5``,``p6``,总结了一些经验希望和大家分享一下，由于水平有限，`如果哪里出现了错误希望大家在评论区不吝赐教`。

​       好了，接下来进入正文部分，``p5``,``p6``课上指令应该就就条件存，跳转，计算类（除了第一次``p6``出现了``jap``这样的指令），以下方法都是基于``AT``法，分布式译码以及暴力转发框架为前提。

* 对于计算类：

  ​       相信大家在控制信号中已经进行过指令的分类了，一般来说计算类就只有``calculate_r``,``caculate_i``,``md(乘除)``三类，当然还有一个稍微特殊一点的``movz``，这个指令本来应该归到``calculate_r``里面，但是它是否写入得到``E``集``alu``计算出来才知道，所以我在条件访存类指令时再讲该条指令。经过了以上分类，那么基本上课上加指令时主要就是改改``E_alu``，``E_mdu``的功能，然后在``ctrl``里面把该指令归类到上述的``calculate_r``,``caculate_i``,``md(乘除)``三类中去，阻塞和转发，以及控制信号根本不用动（前提大家的阻塞，控制信号都是按类来选，而不是单条指令来选控制信号，阻塞的）。

* 对于分支跳转类指令：

  ​      ``j``类指令好像就出过``jap``，之前有人发过怎么实现，就不讲了，以下主要讲讲常考的``branch``类，具体就可以分为两类：

  * 条件链接和无条件链接：

    ​       无条件链接就非常简单，就像``jal``或是``jalr``那样链接就好，至于条件链接就要复杂一点，因为我们要根据``D_cmp``得到的``b_j``信号来决定是否链接，于是乎我们将该信号流水下去，并在``E``级,``M``级，``W``级将该信号连到``ctrl``里面做如下判断：

    ```verilog
    assign gwa_res = ...
        			(bgezal | bltzal)?((b_j)?5'd31: 5'b0 ):
    				...	  
    ```

    ​         如果不链接我们就将``pc + 8``写入``0``号寄存器，因为写入``0``号寄存器的值不会被转发，同时也写不进去，所以不会产生任何有效行为，至于阻塞怎么办，将该类指令归入``branch``类指令或者像``beq``那样判断要用什么就好，大家课下可以加一下``bltzal``或者``bgezal``这两条指令集和``mars``有的指令，建议按``mars``中的条件链接来加（指令集中为无条件链接），加完后直接带到课上，这样课上连``b_j``流水都不用管了，只用管一下跳哪儿，什么情况跳，加加控制信号就好。

  * 是否清空延迟槽：

    ​          一般指令集会这样描述：

    ```verilog
    I+1: if condition:
    		PC <- PC + starget_offest	
          else:
    		NullilyCurrentInstruction()
          endif
    ```

    就是不跳转的时候不执行下一条指令（延迟槽中的指令）而是执行下下条指令，那么这种情况就需要我们在不跳的时候在上升沿清空``F``级到``D``级的寄存器，相当于时沿迟槽中指令变为``nop``，但要注意如果当我的该条跳转类指令被阻塞在``D``级的时候千万不要清空延迟槽，因为被阻塞说明它现在还没有得到正确的转发后的寄存器的值，对于是否跳转这个结果可能会出现错误的判断，如果此时判断要清，但之后得到了正确的转发结果判断要跳转，延迟槽在这时候已经被清除了，就错了。

    ​        以下说一下具体实现，首先在``mips.v``的``D``级做一个判断，判断是否清延迟槽(以``bonall``这条指令为例)，

    ```verilog
    wire D_flush = bonall && !b_j;
    ```

    然后将其连到``F``到``D``级寄存器中，注意阻塞时不清延迟槽。

    ```verilog
    F_D_REG f_d_reg (
        .reset(reset| (D_flush && !stall)), // bonall
        .clk(clk), 
        .we(D_we), 
        .instr_in(F_instr), 
        .instr_out(D_instr),
        .pc_in(F_pc), 
        .pc_out(D_pc)
        );
    ```

    

* 对于条件访存类：

  ​        主要也是两类，用``M``级的数据算出是否写寄存器，又或者是算出写哪个寄存器，其实这两类我认为可以是同一类的，因为如果是是否写寄存器，它如果算出来不写那么我们就有可以让它去写``0``号寄存器，反正写``0``号寄存器也不会写入以及被转发，所以它相当于是算出结果判断要么写``0``号寄存器，要么写别的。

  ​		由于在``M``级同过计算就得到了写入地址，那么我将其或者是一个判断信号连接到``M``级``ctrl``里面，具体实现如下：

  * 对于``lhonez``这种半字``0``多写``31``号寄存器，写``pc + 4``（如果没错，有可能是``pc + 8``）,否则写``rt``,写这个半字的指令我们可以这样，首先在``M_dm``里面得到一个控制信号如下：

    ```verilog
    		integer i;
    		reg [31:0] o = 0;
    		reg [31:0] z = 0;
    		always@(*)begin
    			o = 0;
    			z = 0;
                for(i = 0; i < 16; i = i + 1)begin//hf为读出的半字
    				if(hf[i] == 1'b1) o = o + 1;
    				else z = z + 1;
    			end
    			if(o > z) lhonez_ch = 1'b1;
    			else lhonez_ch = 1'b0;
    		end
    ```

    由于我在``M``级已经得到了``lhonez_ch``信号，于是乎我认为在``M``级就知道了写入地址，可以将其连到``M``级``ctrl``里面，同时将该信号流水到``W``级里面并连到``ctrl``里面，然后操作如下：

    ```verilog
    wire [4:0] lhonez_a = (lhonez_ch === 1'bz || lhonez_ch === 1'bx)? 0 : (lhonez_ch === 1'b1)? rt : 32'd31;
    assign gwa_res = ...//grf写入地址
    				(lhonez)? lhonez_a :
    				 ...   
    assign gwd_sel = ... //grf写入什么值
    				(lhonez)?((lhonez_ch === 1'b1)? `gwd_dm : `gwd_pc4):
    				...
    ```

    注意一下在``M``级前面我们并没有得到写入地址，也没有将``lhonez_ch``信号连进``ctrl``里面，因此该信号的值会是``z``，于是我们用``====``判断，在``E``级或是``D``级时它写``0``号寄存器（因为不会产生任何影响），在这里暂时先不考虑阻塞问题。

    ​       同时对于该指令有个细节要说一下,它如果写``31``那么就是写``pc + 4``，由于转发只有``pc + 8``因此这里必须要改改:

    ```verilog
    assign fw_E_wd = (E_gwd_sel == `gwd_pc8)? E_pc + 8:
    				 (E_gwd_sel == `gwd_pc4)? E_pc + 4:
    				 32'd0;
    							
    	 assign fw_M_wd = (M_gwd_sel == `gwd_alu)? M_alu_out:
    					  (M_gwd_sel == `gwd_pc8)? M_pc + 8:
    					  (M_gwd_sel == `gwd_pc4)? M_pc + 4:
    					  (M_gwd_sel == `gwd_md)? M_md_out:
    					  32'd0;
    							
    	 assign fw_W_wd = (W_gwd_sel == `gwd_alu)? W_alu_out:
    					  (W_gwd_sel == `gwd_dm)? W_dm_out:
    					  (W_gwd_sel == `gwd_pc8)? W_pc + 8:
    					  (W_gwd_sel == `gwd_pc4)? W_pc + 4:
    					  (W_gwd_sel == `gwd_md)? W_md_out:
    					   32'd0;
    ```

    ​       好了，接下来的阻塞又是一个重点了：如果条件访存在M级就得到了写入地址，如上图就是`M`级的`CTRL`的`GRF`写入地址，对于`lhonez`这条指令已经得到写入地址了（就相当于在`M`级和`lw`一样知道写入地址，写入值了，而不是在`W`级才将写入地址连到`CTRL`里面 ），那么就是说在`M`级前不知到写入地址，那么当该条指令在`E`级时要特判一下阻塞，在`M`级就像正常的`load`类指令（将该类指令归入``load``类）用`Tuse`,`Tnew`判断就好了

    ​         但是注意上面说的可能有`bug`,建议该指令在`M`级的时候也像`E`那样特判阻塞，严格来说不用，但是我`p5`应该就是因为这个挂了第`3`题，`p6`前两道做的快，于是有时间，就在阻塞这里反复试探发现特判时硬阻一个周期过不了，条件阻一个也过不了，硬阻两个只有一个点`TLE`了，于是条件阻两个周期就过了

     但是按照最上面的分析来说其实只用条件阻一个周期，就是该指令在`E`级时条件阻。在`M`级时候不用特判然后条件阻，而是用像`lw`那样的`Tuse`,`Tnew`判断就好，不用改阻塞。至于为什么过不了，分析了一下，应该是在`M`级得到``lhonez_ch``信号，连到`M`级`CTRL`后组合逻辑得到地址不是在时钟上升沿开始，而是慢了一点点，所以在上升沿开始时`lhonez_ch`有可能是`z`又或者是上一条指令留下来的值，写入地址是`0`或是别的，所以如果此时`D`的指令本来应该会被阻塞，那么就有可能不会被阻塞（阻塞判断就在上升沿时），所以在`M`级还是得特判才会阻塞成功。

    ​        总之如果是按照上面做法做的建议特判条件阻两个周期（你可能会说那和`W`级再得到结果，在``M``级不连到``ctrl``里面，在``W``级才连有什么区别吗？我觉得没什么区别了。。。），下面代码就只条件阻了一个周期，再复制一遍，把`E`改成`M`就好了：

    ```verilog
    assign stall_lhonez = (E_lhonez && (((D_rs == E_rt || D_rs == 5'd31) && (D_rs != 5'd0) && (Tuse_rs < Tnew_E)) || ((D_rt == E_rt || D_rt == 5'd31) && (D_rs != 5'd0) && (Tuse_rt < Tnew_E))));
    ```

  * 然后是``lwer``这种需要用``dm_out``,``rt_data``计算地址的可以这样写：

    ```verilog
    wire lwer_ch = lwer && mem_word && rt_d;
    assign gwa_res = ...
                     (lwer)? ((lwer_ch !== 1'bz && lwer_ch !== 1'bx)?((mem_word + rt_d)& 5'h1e) : 5'b0) : 
                     ...
    ```

  * 最后是``movz``（``rt_data == 0``将``rs_data``写到``rd``里面否则不写，该指令``mars``里面有，大家可以练练），它在`E`级时应该也要特判阻塞，因为道理同访存（我刚开始认为它在``E``级就得到结果了，就和一条正常的``calculate_r``没有区别了），在`E`级得到写不写`rt`也会有组合逻辑延时。

好了，以上就是分享的所有内容了，如果大家有想法欢迎补充，由于本人太菜，如果说的有错误，也请大家在评论区指出，免得有人被我误导了。